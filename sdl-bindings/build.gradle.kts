import java.nio.file.Files

/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    id("buildlogic.java-library-conventions")
}

dependencies {
    api(project(":sdl-native"))
}

tasks {
    val mkdir by registering {
        group = "sdl-bindings"
        description = "Ensures that the 'jextract/' directory exists under the build directory"

        val jextractPath = jextractDefaultDir.get().asFile.toPath()
        doLast {
            Files.createDirectories(jextractPath)
        }
    }

    val download by registering(JextractDownloadTask::class) {
        group = "sdl-bindings"
        description = "Downloads pre-build jextract binaries archive file using curl"
        dependsOn(mkdir)

        val jdkVersion = 22
        val buildId = 6
        val buildNum = 47
        val curlExecutable = resolveExecutable(Binaries.curl)

        curlBinary.set(objects.property(String::class).convention(curlExecutable))
        jextractSpec.set(JextractSpec(platform, architecture, jdkVersion, buildId, buildNum))
        jextractBaseDir.set(jextractDefaultDir)

        // NOTE: this seems silly, but apparently the output val must be set here rather than in exec() or init{} in the task class?
        downloadedArchiveFile.set(
            jextractSpec.map { spec ->
                jextractBaseDir.file(
                    "jextract_${spec.jdkVersion}+${spec.buildId}-${spec.buildNum}_${spec.platform}-${spec.architecture}.tar.gz"
                ).get()
            }
        )
    }

    val unpack by registering(JextractUnpackTask::class) {
        group = "sdl-bindings"
        description = "Unpacks jextract archive file downloaded by 'downloadJextract' task"

        dependsOn(download)

        val tarExecutable = resolveExecutable(Binaries.tar)

        tarBinary.set(objects.property(String::class).convention(tarExecutable))
        inputArchiveFile.set(download.flatMap { it.downloadedArchiveFile })
        jextractBaseDir.set(jextractDefaultDir)
    }

    val bindings by registering(JextractGenerateBindings::class) {
        group = "sdl-bindings"
        description = "Generate Java bindings for SDL using jextract unpacked back 'unpackJextract' task"

        dependsOn(unpack)

        baseDir.set(layout.projectDirectory.dir(".."))
        jextractBaseDir.set(jextractDefaultDir)
    }

    named("build") {
        dependsOn(download, unpack)
    }

    named("compileJava") {
        dependsOn(bindings)
    }
}

// ----------------------------------------------------------------------------
// Types, functions, and common values used by tasks
// ----------------------------------------------------------------------------

val jextractDefaultDir: DirectoryProperty = objects.directoryProperty()
    .convention(layout.buildDirectory.dir("jextract"))

data class JextractSpec(
    @Input val platform: String,
    @Input val architecture: String,
    @Input val jdkVersion: Int,
    @Input val buildId: Int,
    @Input val buildNum: Int
)

data class ExecutableBinary(
    val defaultName: String,
    val envVarOverride: String
)

object Binaries {
    val curl = ExecutableBinary("curl", "CURL_PATH")
    val tar = ExecutableBinary("tar", "TAR_PATH")
}

val osArch: String = System.getProperty("os.arch")
val osName: String = System.getProperty("os.name")

val platform: String = when {
    osName.contains("mac", ignoreCase = true) -> "macos"
    osName.contains("linux", ignoreCase = true) -> "linux"
    osName.contains("windows", ignoreCase = true) -> "windows"
    else -> osName
}

val architecture: String = when {
    osArch.contains("aarch64", ignoreCase = true) -> "aarch64"
    osArch.contains("64", ignoreCase = true) -> "x64"
    else -> osArch
}

/**
 * Resolve an executable by checking for an overriding environment variable
 * and if not found, falling back to the specified default, appending
 * an ".exe" suffix if running on windows.
 */
fun resolveExecutable(binary: ExecutableBinary): String {
    val isWindows = platform == "windows"
    val noSuffix = !binary.defaultName.endsWith(".exe")
    val override = System.getenv(binary.envVarOverride)

    val executable = when {
        !override.isNullOrBlank() -> override
        (isWindows && noSuffix) -> "${binary.defaultName}.exe"
        else -> binary.defaultName
    }

    val isOverride = executable == override
    val overrideMsg = if (isOverride) " from environment ${binary.envVarOverride}" else ""
    logger.debug("Using executable$overrideMsg: $executable")

    return executable
}

// ----------------------------------------------------------------------------
// Custom task types
// ----------------------------------------------------------------------------

/**
 * Using curl, download an archive containing pre-build jextract binaries
 * for supported platforms, architectures, jdk versions, and build versions.
 * See <a href="https://jdk.java.net/jextract/">https://jdk.java.net/jextract/</a> for the latest options.
 */
abstract class JextractDownloadTask : Exec() {

    @get:Input
    abstract val curlBinary: Property<String>

    @get:Nested
    abstract val jextractSpec: Property<JextractSpec>

    @get:InputDirectory
    abstract val jextractBaseDir: DirectoryProperty

    @get:OutputFile
    abstract val downloadedArchiveFile: RegularFileProperty

    @TaskAction
    override fun exec() {
        val spec = jextractSpec.get()

        val urlBase = "https://download.java.net/java/early_access/jextract"
        val urlPath = getJextractUrlPath(spec)
        val downloadUrl = "$urlBase$urlPath"

        workingDir = jextractBaseDir.get().asFile
        executable = curlBinary.get()
        args(
            "--output", downloadedArchiveFile.get().asFile.absolutePath,
            "--location", downloadUrl
        )

        super.exec()
    }

    private fun getJextractUrlPath(spec: JextractSpec): String {
        val platformArch = "${spec.platform}-${spec.architecture}"
        val supported = listOf("linux-aarch64", "linux-x64", "macos-aarch64", "macos-x64", "windows-x64")
        return if (supported.contains(platformArch)) {
            "/${spec.jdkVersion}/${spec.buildId}/openjdk-${spec.jdkVersion}-jextract+${spec.buildId}-${spec.buildNum}_${platformArch}_bin.tar.gz"
        } else {
            error("Unsupported platform/architecture combination for jextract binaries: $platformArch")
        }
    }
}

/**
 * Using tar, unpack an archive containing pre-build jextract binaries downloaded by JextractDownloadTask
 * TODO(brian): replace with the default `Tar` task type:
 *   https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/bundling/Tar.html
 */
abstract class JextractUnpackTask : Exec() {

    @get:Input
    abstract val tarBinary: Property<String>

    @get:InputFile
    abstract val inputArchiveFile: RegularFileProperty

    @get:InputDirectory
    abstract val jextractBaseDir: DirectoryProperty

    @TaskAction
    override fun exec() {
        workingDir = jextractBaseDir.get().asFile
        executable = tarBinary.get()
        args(
            "--extract",
            "--gzip",
            "--file=${inputArchiveFile.get().asFile.absolutePath}",
            // removes top-level 'jextract-{jdkVersion}/' folder from the archive contents
            "--strip-components=1"
        )
        super.exec()
    }
}

/**
 * Executes jextract in order to generate java bindings for sdl
 */
abstract class JextractGenerateBindings : Exec() {

    @get:InputDirectory
    abstract val baseDir: DirectoryProperty

    @get:InputDirectory
    abstract val jextractBaseDir: DirectoryProperty

    @TaskAction
    override fun exec() {
        val jextractJavaBinary = jextractBaseDir.file("runtime/bin/java")
        val includeDir = baseDir.dir("sdl-native/src/main/cpp/include")
        val outputDir = baseDir.dir("sdl-bindings/src/main/java")

        workingDir = includeDir.get().asFile
        executable = jextractJavaBinary.get().asFile.absolutePath
        args(
            "--module",         "org.openjdk.jextract/org.openjdk.jextract.JextractTool",
            "--library",        "SDL3",
            "--target-package", "org.libsdl.sdl",
            "--include-dir",    includeDir.get().asFile.absolutePath,
            "--output",         outputDir.get().asFile.absolutePath,
            "SDL3/SDL.h"
        )
        super.exec()
    }
}
