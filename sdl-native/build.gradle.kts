import java.nio.file.Files

/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    id("buildlogic.java-library-conventions")
}

tasks {
    val mkdir by registering {
        group = "sdl-bindings"
        description = "Ensures that the 'jextract/' directory exists under the build directory"

        val sdlBuildPath = layout.buildDirectory.dir("sdl").get().asFile.toPath()
        doLast {
            Files.createDirectories(sdlBuildPath)
        }
    }

    val configure by registering(CMakeConfigureSDL::class) {
        group = "sdl-native"
        description = "Configure SDL build system using cmake"
        dependsOn(mkdir)

        val cmakeExecutable = resolveExecutable(Binaries.cmake)

        cmakeBinary.set(objects.property(String::class).convention(cmakeExecutable))
        sdlSourceDir.set(layout.projectDirectory.dir("src/main/cpp"))
        sdlBuildDir.set(layout.buildDirectory.dir("sdl"))
    }

    val libsdl by registering(CMakeBuildLibrarySDL::class) {
        group = "sdl-native"
        description = "Configure SDL build system using cmake"
        dependsOn(configure)

        val cmakeExecutable = resolveExecutable(Binaries.cmake)

        cmakeBinary.set(objects.property(String::class).convention(cmakeExecutable))
        sdlBuildDir.set(layout.buildDirectory.dir("sdl"))
    }
}

data class ExecutableBinary(
    val defaultName: String,
    val envVarOverride: String
)

object Binaries {
    val cmake = ExecutableBinary("cmake", "CMAKE_PATH")
}

val osArch: String = System.getProperty("os.arch")
val osName: String = System.getProperty("os.name")

val platform: String = when {
    osName.contains("mac", ignoreCase = true) -> "macos"
    osName.contains("linux", ignoreCase = true) -> "linux"
    osName.contains("windows", ignoreCase = true) -> "windows"
    else -> osName
}

val architecture: String = when {
    osArch.contains("aarch64", ignoreCase = true) -> "aarch64"
    osArch.contains("64", ignoreCase = true) -> "x64"
    else -> osArch
}

/**
 * Resolve an executable by checking for an overriding environment variable
 * and if not found, falling back to the specified default, appending
 * an ".exe" suffix if running on windows.
 */
fun resolveExecutable(binary: ExecutableBinary): String {
    val isWindows = platform == "windows"
    val noSuffix = !binary.defaultName.endsWith(".exe")
    val override = System.getenv(binary.envVarOverride)

    val executable = when {
        !override.isNullOrBlank() -> override
        (isWindows && noSuffix) -> "${binary.defaultName}.exe"
        else -> binary.defaultName
    }

    val isOverride = executable == override
    val overrideMsg = if (isOverride) " from environment ${binary.envVarOverride}" else ""
    logger.debug("Using executable$overrideMsg: $executable")

    return executable
}

// ----------------------------------------------------------------------------
// Custom task types
// ----------------------------------------------------------------------------

/**
 * Executes cmake to configure build scripts for SDL
 */
abstract class CMakeConfigureSDL : Exec() {

    @get:Input
    abstract val cmakeBinary: Property<String>

    @get:InputDirectory
    abstract val sdlSourceDir: DirectoryProperty

    @get:InputDirectory
    abstract val sdlBuildDir: DirectoryProperty

    @TaskAction
    override fun exec() {
        executable = cmakeBinary.get()
        args(
            "-S", sdlSourceDir.get().asFile.absolutePath,
            "-B", sdlBuildDir.get().asFile.absolutePath
        )
        super.exec()
    }
}

/**
 * Executes cmake to build the SDL shared library
 */
abstract class CMakeBuildLibrarySDL : Exec() {

    @get:Input
    abstract val cmakeBinary: Property<String>

    @get:InputDirectory
    abstract val sdlBuildDir: DirectoryProperty

    @TaskAction
    override fun exec() {
        executable = cmakeBinary.get()
        args("--build", sdlBuildDir.get().asFile.absolutePath, "--parallel")
        super.exec()
    }
}
